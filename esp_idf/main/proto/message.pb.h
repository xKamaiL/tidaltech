// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fmessage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fmessage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2fmessage_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fmessage_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_proto_2fmessage_2eproto;
class DeviceInformationRequest;
struct DeviceInformationRequestDefaultTypeInternal;
extern DeviceInformationRequestDefaultTypeInternal _DeviceInformationRequest_default_instance_;
class DeviceInformationResponse;
struct DeviceInformationResponseDefaultTypeInternal;
extern DeviceInformationResponseDefaultTypeInternal _DeviceInformationResponse_default_instance_;
class Effect;
struct EffectDefaultTypeInternal;
extern EffectDefaultTypeInternal _Effect_default_instance_;
class GetSceneResponse;
struct GetSceneResponseDefaultTypeInternal;
extern GetSceneResponseDefaultTypeInternal _GetSceneResponse_default_instance_;
class LightingScheduleRequest;
struct LightingScheduleRequestDefaultTypeInternal;
extern LightingScheduleRequestDefaultTypeInternal _LightingScheduleRequest_default_instance_;
class SetSceneRequest;
struct SetSceneRequestDefaultTypeInternal;
extern SetSceneRequestDefaultTypeInternal _SetSceneRequest_default_instance_;
class TimeStamp;
struct TimeStampDefaultTypeInternal;
extern TimeStampDefaultTypeInternal _TimeStamp_default_instance_;
class UpgradeFirmwareRequest;
struct UpgradeFirmwareRequestDefaultTypeInternal;
extern UpgradeFirmwareRequestDefaultTypeInternal _UpgradeFirmwareRequest_default_instance_;
class UpgradeFirmwareResponse;
struct UpgradeFirmwareResponseDefaultTypeInternal;
extern UpgradeFirmwareResponseDefaultTypeInternal _UpgradeFirmwareResponse_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum Scene : int {
  SCENE_UNSPECIFIED = 0,
  Scene_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Scene_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Scene_IsValid(int value);
constexpr Scene Scene_MIN = static_cast<Scene>(0);
constexpr Scene Scene_MAX = static_cast<Scene>(0);
constexpr int Scene_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
Scene_descriptor();
template <typename T>
const std::string& Scene_Name(T value) {
  static_assert(std::is_same<T, Scene>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Scene_Name().");
  return Scene_Name(static_cast<Scene>(value));
}
template <>
inline const std::string& Scene_Name(Scene value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Scene_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool Scene_Parse(absl::string_view name, Scene* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Scene>(
      Scene_descriptor(), name, value);
}
enum CommandCode : int {
  COMMAND_CODE_UNSPECIFIED = 0,
  COMMAND_CODE_GET_PROPERTIES = 1,
  COMMAND_CODE_SET_LIGHTING = 5,
  COMMAND_CODE_UPGRADE_FIRMWARE = 6,
  CommandCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommandCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommandCode_IsValid(int value);
constexpr CommandCode CommandCode_MIN = static_cast<CommandCode>(0);
constexpr CommandCode CommandCode_MAX = static_cast<CommandCode>(6);
constexpr int CommandCode_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
CommandCode_descriptor();
template <typename T>
const std::string& CommandCode_Name(T value) {
  static_assert(std::is_same<T, CommandCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CommandCode_Name().");
  return CommandCode_Name(static_cast<CommandCode>(value));
}
template <>
inline const std::string& CommandCode_Name(CommandCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommandCode_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool CommandCode_Parse(absl::string_view name, CommandCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandCode>(
      CommandCode_descriptor(), name, value);
}
enum Mode : int {
  MODE_UNSPECIFIED = 0,
  MODE_MANUAL = 1,
  MODE_SCHEDULE = 2,
  Mode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Mode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Mode_IsValid(int value);
constexpr Mode Mode_MIN = static_cast<Mode>(0);
constexpr Mode Mode_MAX = static_cast<Mode>(2);
constexpr int Mode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Mode_descriptor();
template <typename T>
const std::string& Mode_Name(T value) {
  static_assert(std::is_same<T, Mode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Mode_Name().");
  return Mode_Name(static_cast<Mode>(value));
}
template <>
inline const std::string& Mode_Name(Mode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Mode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Mode_Parse(absl::string_view name, Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mode>(
      Mode_descriptor(), name, value);
}
enum LED : int {
  LED_UNSPECIFIED = 0,
  LED_WHITE = 1,
  LED_WARM_WHITE = 2,
  LED_RED = 3,
  LED_GREEN = 4,
  LED_BLUE = 5,
  LED_ROYAL_BLUE = 6,
  LED_ULTRA_VIOLET = 7,
  LED_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LED_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LED_IsValid(int value);
constexpr LED LED_MIN = static_cast<LED>(0);
constexpr LED LED_MAX = static_cast<LED>(7);
constexpr int LED_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
LED_descriptor();
template <typename T>
const std::string& LED_Name(T value) {
  static_assert(std::is_same<T, LED>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LED_Name().");
  return LED_Name(static_cast<LED>(value));
}
template <>
inline const std::string& LED_Name(LED value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LED_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool LED_Parse(absl::string_view name, LED* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LED>(
      LED_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class DeviceInformationRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DeviceInformationRequest) */ {
 public:
  inline DeviceInformationRequest() : DeviceInformationRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceInformationRequest(::google::protobuf::internal::ConstantInitialized);

  DeviceInformationRequest(const DeviceInformationRequest& from);
  DeviceInformationRequest(DeviceInformationRequest&& from) noexcept
    : DeviceInformationRequest() {
    *this = ::std::move(from);
  }

  inline DeviceInformationRequest& operator=(const DeviceInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInformationRequest& operator=(DeviceInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInformationRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceInformationRequest*>(
               &_DeviceInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeviceInformationRequest& a, DeviceInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInformationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInformationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInformationRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeviceInformationRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeviceInformationRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DeviceInformationRequest";
  }
  protected:
  explicit DeviceInformationRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DeviceInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};// -------------------------------------------------------------------

class DeviceInformationResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DeviceInformationResponse) */ {
 public:
  inline DeviceInformationResponse() : DeviceInformationResponse(nullptr) {}
  ~DeviceInformationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceInformationResponse(::google::protobuf::internal::ConstantInitialized);

  DeviceInformationResponse(const DeviceInformationResponse& from);
  DeviceInformationResponse(DeviceInformationResponse&& from) noexcept
    : DeviceInformationResponse() {
    *this = ::std::move(from);
  }

  inline DeviceInformationResponse& operator=(const DeviceInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInformationResponse& operator=(DeviceInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInformationResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceInformationResponse*>(
               &_DeviceInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceInformationResponse& a, DeviceInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInformationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInformationResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInformationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceInformationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeviceInformationResponse& from) {
    DeviceInformationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInformationResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DeviceInformationResponse";
  }
  protected:
  explicit DeviceInformationResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kIdFieldNumber = 4,
    kVersionFieldNumber = 5,
    kModeFieldNumber = 1,
    kCurrentTimestampsFieldNumber = 2,
  };
  // string name = 3;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string id = 4;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string version = 5;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .Mode mode = 1;
  void clear_mode() ;
  ::Mode mode() const;
  void set_mode(::Mode value);

  private:
  ::Mode _internal_mode() const;
  void _internal_set_mode(::Mode value);

  public:
  // uint32 current_timestamps = 2;
  void clear_current_timestamps() ;
  ::uint32_t current_timestamps() const;
  void set_current_timestamps(::uint32_t value);

  private:
  ::uint32_t _internal_current_timestamps() const;
  void _internal_set_current_timestamps(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DeviceInformationResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    int mode_;
    ::uint32_t current_timestamps_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};// -------------------------------------------------------------------

class LightingScheduleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LightingScheduleRequest) */ {
 public:
  inline LightingScheduleRequest() : LightingScheduleRequest(nullptr) {}
  ~LightingScheduleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LightingScheduleRequest(::google::protobuf::internal::ConstantInitialized);

  LightingScheduleRequest(const LightingScheduleRequest& from);
  LightingScheduleRequest(LightingScheduleRequest&& from) noexcept
    : LightingScheduleRequest() {
    *this = ::std::move(from);
  }

  inline LightingScheduleRequest& operator=(const LightingScheduleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightingScheduleRequest& operator=(LightingScheduleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LightingScheduleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LightingScheduleRequest* internal_default_instance() {
    return reinterpret_cast<const LightingScheduleRequest*>(
               &_LightingScheduleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LightingScheduleRequest& a, LightingScheduleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LightingScheduleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightingScheduleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LightingScheduleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LightingScheduleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LightingScheduleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LightingScheduleRequest& from) {
    LightingScheduleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightingScheduleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "LightingScheduleRequest";
  }
  protected:
  explicit LightingScheduleRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHhFieldNumber = 1,
    kMmFieldNumber = 2,
    kWhiteFieldNumber = 3,
    kWarmWhiteFieldNumber = 4,
    kRedFieldNumber = 5,
    kGreenFieldNumber = 6,
    kBlueFieldNumber = 7,
    kRoyalBlueFieldNumber = 8,
    kUltraVioletFieldNumber = 9,
  };
  // optional uint32 hh = 1;
  bool has_hh() const;
  void clear_hh() ;
  ::uint32_t hh() const;
  void set_hh(::uint32_t value);

  private:
  ::uint32_t _internal_hh() const;
  void _internal_set_hh(::uint32_t value);

  public:
  // optional uint32 mm = 2;
  bool has_mm() const;
  void clear_mm() ;
  ::uint32_t mm() const;
  void set_mm(::uint32_t value);

  private:
  ::uint32_t _internal_mm() const;
  void _internal_set_mm(::uint32_t value);

  public:
  // optional uint32 white = 3;
  bool has_white() const;
  void clear_white() ;
  ::uint32_t white() const;
  void set_white(::uint32_t value);

  private:
  ::uint32_t _internal_white() const;
  void _internal_set_white(::uint32_t value);

  public:
  // optional uint32 warm_white = 4;
  bool has_warm_white() const;
  void clear_warm_white() ;
  ::uint32_t warm_white() const;
  void set_warm_white(::uint32_t value);

  private:
  ::uint32_t _internal_warm_white() const;
  void _internal_set_warm_white(::uint32_t value);

  public:
  // optional uint32 red = 5;
  bool has_red() const;
  void clear_red() ;
  ::uint32_t red() const;
  void set_red(::uint32_t value);

  private:
  ::uint32_t _internal_red() const;
  void _internal_set_red(::uint32_t value);

  public:
  // optional uint32 green = 6;
  bool has_green() const;
  void clear_green() ;
  ::uint32_t green() const;
  void set_green(::uint32_t value);

  private:
  ::uint32_t _internal_green() const;
  void _internal_set_green(::uint32_t value);

  public:
  // optional uint32 blue = 7;
  bool has_blue() const;
  void clear_blue() ;
  ::uint32_t blue() const;
  void set_blue(::uint32_t value);

  private:
  ::uint32_t _internal_blue() const;
  void _internal_set_blue(::uint32_t value);

  public:
  // optional uint32 royal_blue = 8;
  bool has_royal_blue() const;
  void clear_royal_blue() ;
  ::uint32_t royal_blue() const;
  void set_royal_blue(::uint32_t value);

  private:
  ::uint32_t _internal_royal_blue() const;
  void _internal_set_royal_blue(::uint32_t value);

  public:
  // optional uint32 ultra_violet = 9;
  bool has_ultra_violet() const;
  void clear_ultra_violet() ;
  ::uint32_t ultra_violet() const;
  void set_ultra_violet(::uint32_t value);

  private:
  ::uint32_t _internal_ultra_violet() const;
  void _internal_set_ultra_violet(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:LightingScheduleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t hh_;
    ::uint32_t mm_;
    ::uint32_t white_;
    ::uint32_t warm_white_;
    ::uint32_t red_;
    ::uint32_t green_;
    ::uint32_t blue_;
    ::uint32_t royal_blue_;
    ::uint32_t ultra_violet_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};// -------------------------------------------------------------------

class SetSceneRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SetSceneRequest) */ {
 public:
  inline SetSceneRequest() : SetSceneRequest(nullptr) {}
  ~SetSceneRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetSceneRequest(::google::protobuf::internal::ConstantInitialized);

  SetSceneRequest(const SetSceneRequest& from);
  SetSceneRequest(SetSceneRequest&& from) noexcept
    : SetSceneRequest() {
    *this = ::std::move(from);
  }

  inline SetSceneRequest& operator=(const SetSceneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSceneRequest& operator=(SetSceneRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSceneRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSceneRequest* internal_default_instance() {
    return reinterpret_cast<const SetSceneRequest*>(
               &_SetSceneRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetSceneRequest& a, SetSceneRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSceneRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSceneRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSceneRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSceneRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetSceneRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetSceneRequest& from) {
    SetSceneRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSceneRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SetSceneRequest";
  }
  protected:
  explicit SetSceneRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSceneFieldNumber = 1,
  };
  // .Scene scene = 1;
  void clear_scene() ;
  ::Scene scene() const;
  void set_scene(::Scene value);

  private:
  ::Scene _internal_scene() const;
  void _internal_set_scene(::Scene value);

  public:
  // @@protoc_insertion_point(class_scope:SetSceneRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int scene_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};// -------------------------------------------------------------------

class GetSceneResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GetSceneResponse) */ {
 public:
  inline GetSceneResponse() : GetSceneResponse(nullptr) {}
  ~GetSceneResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetSceneResponse(::google::protobuf::internal::ConstantInitialized);

  GetSceneResponse(const GetSceneResponse& from);
  GetSceneResponse(GetSceneResponse&& from) noexcept
    : GetSceneResponse() {
    *this = ::std::move(from);
  }

  inline GetSceneResponse& operator=(const GetSceneResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSceneResponse& operator=(GetSceneResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSceneResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSceneResponse* internal_default_instance() {
    return reinterpret_cast<const GetSceneResponse*>(
               &_GetSceneResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetSceneResponse& a, GetSceneResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSceneResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSceneResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSceneResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSceneResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSceneResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetSceneResponse& from) {
    GetSceneResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSceneResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "GetSceneResponse";
  }
  protected:
  explicit GetSceneResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSceneFieldNumber = 1,
  };
  // .Scene scene = 1;
  void clear_scene() ;
  ::Scene scene() const;
  void set_scene(::Scene value);

  private:
  ::Scene _internal_scene() const;
  void _internal_set_scene(::Scene value);

  public:
  // @@protoc_insertion_point(class_scope:GetSceneResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int scene_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};// -------------------------------------------------------------------

class Effect final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Effect) */ {
 public:
  inline Effect() : Effect(nullptr) {}
  ~Effect() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Effect(::google::protobuf::internal::ConstantInitialized);

  Effect(const Effect& from);
  Effect(Effect&& from) noexcept
    : Effect() {
    *this = ::std::move(from);
  }

  inline Effect& operator=(const Effect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Effect& operator=(Effect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Effect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Effect* internal_default_instance() {
    return reinterpret_cast<const Effect*>(
               &_Effect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Effect& a, Effect& b) {
    a.Swap(&b);
  }
  inline void Swap(Effect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Effect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Effect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Effect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Effect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Effect& from) {
    Effect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Effect* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Effect";
  }
  protected:
  explicit Effect(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampsFieldNumber = 2,
    kDurationFieldNumber = 1,
  };
  // repeated .TimeStamp timestamps = 2;
  int timestamps_size() const;
  private:
  int _internal_timestamps_size() const;

  public:
  void clear_timestamps() ;
  ::TimeStamp* mutable_timestamps(int index);
  ::google::protobuf::RepeatedPtrField< ::TimeStamp >*
      mutable_timestamps();
  private:
  const ::google::protobuf::RepeatedPtrField<::TimeStamp>& _internal_timestamps() const;
  ::google::protobuf::RepeatedPtrField<::TimeStamp>* _internal_mutable_timestamps();
  public:
  const ::TimeStamp& timestamps(int index) const;
  ::TimeStamp* add_timestamps();
  const ::google::protobuf::RepeatedPtrField< ::TimeStamp >&
      timestamps() const;
  // uint32 duration = 1;
  void clear_duration() ;
  ::uint32_t duration() const;
  void set_duration(::uint32_t value);

  private:
  ::uint32_t _internal_duration() const;
  void _internal_set_duration(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Effect)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::TimeStamp > timestamps_;
    ::uint32_t duration_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};// -------------------------------------------------------------------

class UpgradeFirmwareRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:UpgradeFirmwareRequest) */ {
 public:
  inline UpgradeFirmwareRequest() : UpgradeFirmwareRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpgradeFirmwareRequest(::google::protobuf::internal::ConstantInitialized);

  UpgradeFirmwareRequest(const UpgradeFirmwareRequest& from);
  UpgradeFirmwareRequest(UpgradeFirmwareRequest&& from) noexcept
    : UpgradeFirmwareRequest() {
    *this = ::std::move(from);
  }

  inline UpgradeFirmwareRequest& operator=(const UpgradeFirmwareRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpgradeFirmwareRequest& operator=(UpgradeFirmwareRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpgradeFirmwareRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpgradeFirmwareRequest* internal_default_instance() {
    return reinterpret_cast<const UpgradeFirmwareRequest*>(
               &_UpgradeFirmwareRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpgradeFirmwareRequest& a, UpgradeFirmwareRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpgradeFirmwareRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpgradeFirmwareRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpgradeFirmwareRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpgradeFirmwareRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpgradeFirmwareRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpgradeFirmwareRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UpgradeFirmwareRequest";
  }
  protected:
  explicit UpgradeFirmwareRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:UpgradeFirmwareRequest)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};// -------------------------------------------------------------------

class UpgradeFirmwareResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UpgradeFirmwareResponse) */ {
 public:
  inline UpgradeFirmwareResponse() : UpgradeFirmwareResponse(nullptr) {}
  ~UpgradeFirmwareResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpgradeFirmwareResponse(::google::protobuf::internal::ConstantInitialized);

  UpgradeFirmwareResponse(const UpgradeFirmwareResponse& from);
  UpgradeFirmwareResponse(UpgradeFirmwareResponse&& from) noexcept
    : UpgradeFirmwareResponse() {
    *this = ::std::move(from);
  }

  inline UpgradeFirmwareResponse& operator=(const UpgradeFirmwareResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpgradeFirmwareResponse& operator=(UpgradeFirmwareResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpgradeFirmwareResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpgradeFirmwareResponse* internal_default_instance() {
    return reinterpret_cast<const UpgradeFirmwareResponse*>(
               &_UpgradeFirmwareResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpgradeFirmwareResponse& a, UpgradeFirmwareResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpgradeFirmwareResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpgradeFirmwareResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpgradeFirmwareResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpgradeFirmwareResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpgradeFirmwareResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpgradeFirmwareResponse& from) {
    UpgradeFirmwareResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpgradeFirmwareResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UpgradeFirmwareResponse";
  }
  protected:
  explicit UpgradeFirmwareResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentVersionFieldNumber = 2,
    kIsLatestVersionFieldNumber = 1,
  };
  // string current_version = 2;
  void clear_current_version() ;
  const std::string& current_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_version(Arg_&& arg, Args_... args);
  std::string* mutable_current_version();
  PROTOBUF_NODISCARD std::string* release_current_version();
  void set_allocated_current_version(std::string* ptr);

  private:
  const std::string& _internal_current_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_version(
      const std::string& value);
  std::string* _internal_mutable_current_version();

  public:
  // bool is_latest_version = 1;
  void clear_is_latest_version() ;
  bool is_latest_version() const;
  void set_is_latest_version(bool value);

  private:
  bool _internal_is_latest_version() const;
  void _internal_set_is_latest_version(bool value);

  public:
  // @@protoc_insertion_point(class_scope:UpgradeFirmwareResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr current_version_;
    bool is_latest_version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};// -------------------------------------------------------------------

class TimeStamp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TimeStamp) */ {
 public:
  inline TimeStamp() : TimeStamp(nullptr) {}
  ~TimeStamp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeStamp(::google::protobuf::internal::ConstantInitialized);

  TimeStamp(const TimeStamp& from);
  TimeStamp(TimeStamp&& from) noexcept
    : TimeStamp() {
    *this = ::std::move(from);
  }

  inline TimeStamp& operator=(const TimeStamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeStamp& operator=(TimeStamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeStamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeStamp* internal_default_instance() {
    return reinterpret_cast<const TimeStamp*>(
               &_TimeStamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TimeStamp& a, TimeStamp& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeStamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeStamp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeStamp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeStamp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeStamp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TimeStamp& from) {
    TimeStamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeStamp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TimeStamp";
  }
  protected:
  explicit TimeStamp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kWhiteFieldNumber = 3,
    kWarmWhiteFieldNumber = 4,
    kRedFieldNumber = 5,
    kGreenFieldNumber = 6,
    kBlueFieldNumber = 7,
    kRoyalBlueFieldNumber = 8,
    kUltraVioletFieldNumber = 9,
  };
  // uint32 seconds = 1;
  void clear_seconds() ;
  ::uint32_t seconds() const;
  void set_seconds(::uint32_t value);

  private:
  ::uint32_t _internal_seconds() const;
  void _internal_set_seconds(::uint32_t value);

  public:
  // optional uint32 white = 3;
  bool has_white() const;
  void clear_white() ;
  ::uint32_t white() const;
  void set_white(::uint32_t value);

  private:
  ::uint32_t _internal_white() const;
  void _internal_set_white(::uint32_t value);

  public:
  // optional uint32 warm_white = 4;
  bool has_warm_white() const;
  void clear_warm_white() ;
  ::uint32_t warm_white() const;
  void set_warm_white(::uint32_t value);

  private:
  ::uint32_t _internal_warm_white() const;
  void _internal_set_warm_white(::uint32_t value);

  public:
  // optional uint32 red = 5;
  bool has_red() const;
  void clear_red() ;
  ::uint32_t red() const;
  void set_red(::uint32_t value);

  private:
  ::uint32_t _internal_red() const;
  void _internal_set_red(::uint32_t value);

  public:
  // optional uint32 green = 6;
  bool has_green() const;
  void clear_green() ;
  ::uint32_t green() const;
  void set_green(::uint32_t value);

  private:
  ::uint32_t _internal_green() const;
  void _internal_set_green(::uint32_t value);

  public:
  // optional uint32 blue = 7;
  bool has_blue() const;
  void clear_blue() ;
  ::uint32_t blue() const;
  void set_blue(::uint32_t value);

  private:
  ::uint32_t _internal_blue() const;
  void _internal_set_blue(::uint32_t value);

  public:
  // optional uint32 royal_blue = 8;
  bool has_royal_blue() const;
  void clear_royal_blue() ;
  ::uint32_t royal_blue() const;
  void set_royal_blue(::uint32_t value);

  private:
  ::uint32_t _internal_royal_blue() const;
  void _internal_set_royal_blue(::uint32_t value);

  public:
  // optional uint32 ultra_violet = 9;
  bool has_ultra_violet() const;
  void clear_ultra_violet() ;
  ::uint32_t ultra_violet() const;
  void set_ultra_violet(::uint32_t value);

  private:
  ::uint32_t _internal_ultra_violet() const;
  void _internal_set_ultra_violet(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:TimeStamp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 8, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t seconds_;
    ::uint32_t white_;
    ::uint32_t warm_white_;
    ::uint32_t red_;
    ::uint32_t green_;
    ::uint32_t blue_;
    ::uint32_t royal_blue_;
    ::uint32_t ultra_violet_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fmessage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DeviceInformationRequest

// -------------------------------------------------------------------

// DeviceInformationResponse

// .Mode mode = 1;
inline void DeviceInformationResponse::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::Mode DeviceInformationResponse::mode() const {
  // @@protoc_insertion_point(field_get:DeviceInformationResponse.mode)
  return _internal_mode();
}
inline void DeviceInformationResponse::set_mode(::Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:DeviceInformationResponse.mode)
}
inline ::Mode DeviceInformationResponse::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Mode>(_impl_.mode_);
}
inline void DeviceInformationResponse::_internal_set_mode(::Mode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mode_ = value;
}

// uint32 current_timestamps = 2;
inline void DeviceInformationResponse::clear_current_timestamps() {
  _impl_.current_timestamps_ = 0u;
}
inline ::uint32_t DeviceInformationResponse::current_timestamps() const {
  // @@protoc_insertion_point(field_get:DeviceInformationResponse.current_timestamps)
  return _internal_current_timestamps();
}
inline void DeviceInformationResponse::set_current_timestamps(::uint32_t value) {
  _internal_set_current_timestamps(value);
  // @@protoc_insertion_point(field_set:DeviceInformationResponse.current_timestamps)
}
inline ::uint32_t DeviceInformationResponse::_internal_current_timestamps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_timestamps_;
}
inline void DeviceInformationResponse::_internal_set_current_timestamps(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_timestamps_ = value;
}

// string name = 3;
inline void DeviceInformationResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeviceInformationResponse::name() const {
  // @@protoc_insertion_point(field_get:DeviceInformationResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInformationResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceInformationResponse.name)
}
inline std::string* DeviceInformationResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DeviceInformationResponse.name)
  return _s;
}
inline const std::string& DeviceInformationResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DeviceInformationResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInformationResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInformationResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DeviceInformationResponse.name)
  return _impl_.name_.Release();
}
inline void DeviceInformationResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceInformationResponse.name)
}

// string id = 4;
inline void DeviceInformationResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeviceInformationResponse::id() const {
  // @@protoc_insertion_point(field_get:DeviceInformationResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInformationResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceInformationResponse.id)
}
inline std::string* DeviceInformationResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:DeviceInformationResponse.id)
  return _s;
}
inline const std::string& DeviceInformationResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DeviceInformationResponse::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInformationResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInformationResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DeviceInformationResponse.id)
  return _impl_.id_.Release();
}
inline void DeviceInformationResponse::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceInformationResponse.id)
}

// string version = 5;
inline void DeviceInformationResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& DeviceInformationResponse::version() const {
  // @@protoc_insertion_point(field_get:DeviceInformationResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInformationResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceInformationResponse.version)
}
inline std::string* DeviceInformationResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:DeviceInformationResponse.version)
  return _s;
}
inline const std::string& DeviceInformationResponse::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void DeviceInformationResponse::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInformationResponse::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInformationResponse::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DeviceInformationResponse.version)
  return _impl_.version_.Release();
}
inline void DeviceInformationResponse::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceInformationResponse.version)
}

// -------------------------------------------------------------------

// LightingScheduleRequest

// optional uint32 hh = 1;
inline bool LightingScheduleRequest::has_hh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_hh() {
  _impl_.hh_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t LightingScheduleRequest::hh() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.hh)
  return _internal_hh();
}
inline void LightingScheduleRequest::set_hh(::uint32_t value) {
  _internal_set_hh(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.hh)
}
inline ::uint32_t LightingScheduleRequest::_internal_hh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hh_;
}
inline void LightingScheduleRequest::_internal_set_hh(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hh_ = value;
}

// optional uint32 mm = 2;
inline bool LightingScheduleRequest::has_mm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_mm() {
  _impl_.mm_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t LightingScheduleRequest::mm() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.mm)
  return _internal_mm();
}
inline void LightingScheduleRequest::set_mm(::uint32_t value) {
  _internal_set_mm(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.mm)
}
inline ::uint32_t LightingScheduleRequest::_internal_mm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mm_;
}
inline void LightingScheduleRequest::_internal_set_mm(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mm_ = value;
}

// optional uint32 white = 3;
inline bool LightingScheduleRequest::has_white() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_white() {
  _impl_.white_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t LightingScheduleRequest::white() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.white)
  return _internal_white();
}
inline void LightingScheduleRequest::set_white(::uint32_t value) {
  _internal_set_white(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.white)
}
inline ::uint32_t LightingScheduleRequest::_internal_white() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.white_;
}
inline void LightingScheduleRequest::_internal_set_white(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.white_ = value;
}

// optional uint32 warm_white = 4;
inline bool LightingScheduleRequest::has_warm_white() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_warm_white() {
  _impl_.warm_white_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t LightingScheduleRequest::warm_white() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.warm_white)
  return _internal_warm_white();
}
inline void LightingScheduleRequest::set_warm_white(::uint32_t value) {
  _internal_set_warm_white(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.warm_white)
}
inline ::uint32_t LightingScheduleRequest::_internal_warm_white() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.warm_white_;
}
inline void LightingScheduleRequest::_internal_set_warm_white(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.warm_white_ = value;
}

// optional uint32 red = 5;
inline bool LightingScheduleRequest::has_red() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_red() {
  _impl_.red_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t LightingScheduleRequest::red() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.red)
  return _internal_red();
}
inline void LightingScheduleRequest::set_red(::uint32_t value) {
  _internal_set_red(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.red)
}
inline ::uint32_t LightingScheduleRequest::_internal_red() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.red_;
}
inline void LightingScheduleRequest::_internal_set_red(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.red_ = value;
}

// optional uint32 green = 6;
inline bool LightingScheduleRequest::has_green() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_green() {
  _impl_.green_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t LightingScheduleRequest::green() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.green)
  return _internal_green();
}
inline void LightingScheduleRequest::set_green(::uint32_t value) {
  _internal_set_green(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.green)
}
inline ::uint32_t LightingScheduleRequest::_internal_green() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.green_;
}
inline void LightingScheduleRequest::_internal_set_green(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.green_ = value;
}

// optional uint32 blue = 7;
inline bool LightingScheduleRequest::has_blue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_blue() {
  _impl_.blue_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t LightingScheduleRequest::blue() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.blue)
  return _internal_blue();
}
inline void LightingScheduleRequest::set_blue(::uint32_t value) {
  _internal_set_blue(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.blue)
}
inline ::uint32_t LightingScheduleRequest::_internal_blue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blue_;
}
inline void LightingScheduleRequest::_internal_set_blue(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.blue_ = value;
}

// optional uint32 royal_blue = 8;
inline bool LightingScheduleRequest::has_royal_blue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_royal_blue() {
  _impl_.royal_blue_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t LightingScheduleRequest::royal_blue() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.royal_blue)
  return _internal_royal_blue();
}
inline void LightingScheduleRequest::set_royal_blue(::uint32_t value) {
  _internal_set_royal_blue(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.royal_blue)
}
inline ::uint32_t LightingScheduleRequest::_internal_royal_blue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.royal_blue_;
}
inline void LightingScheduleRequest::_internal_set_royal_blue(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.royal_blue_ = value;
}

// optional uint32 ultra_violet = 9;
inline bool LightingScheduleRequest::has_ultra_violet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void LightingScheduleRequest::clear_ultra_violet() {
  _impl_.ultra_violet_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t LightingScheduleRequest::ultra_violet() const {
  // @@protoc_insertion_point(field_get:LightingScheduleRequest.ultra_violet)
  return _internal_ultra_violet();
}
inline void LightingScheduleRequest::set_ultra_violet(::uint32_t value) {
  _internal_set_ultra_violet(value);
  // @@protoc_insertion_point(field_set:LightingScheduleRequest.ultra_violet)
}
inline ::uint32_t LightingScheduleRequest::_internal_ultra_violet() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ultra_violet_;
}
inline void LightingScheduleRequest::_internal_set_ultra_violet(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.ultra_violet_ = value;
}

// -------------------------------------------------------------------

// SetSceneRequest

// .Scene scene = 1;
inline void SetSceneRequest::clear_scene() {
  _impl_.scene_ = 0;
}
inline ::Scene SetSceneRequest::scene() const {
  // @@protoc_insertion_point(field_get:SetSceneRequest.scene)
  return _internal_scene();
}
inline void SetSceneRequest::set_scene(::Scene value) {
  _internal_set_scene(value);
  // @@protoc_insertion_point(field_set:SetSceneRequest.scene)
}
inline ::Scene SetSceneRequest::_internal_scene() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Scene>(_impl_.scene_);
}
inline void SetSceneRequest::_internal_set_scene(::Scene value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.scene_ = value;
}

// -------------------------------------------------------------------

// GetSceneResponse

// .Scene scene = 1;
inline void GetSceneResponse::clear_scene() {
  _impl_.scene_ = 0;
}
inline ::Scene GetSceneResponse::scene() const {
  // @@protoc_insertion_point(field_get:GetSceneResponse.scene)
  return _internal_scene();
}
inline void GetSceneResponse::set_scene(::Scene value) {
  _internal_set_scene(value);
  // @@protoc_insertion_point(field_set:GetSceneResponse.scene)
}
inline ::Scene GetSceneResponse::_internal_scene() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Scene>(_impl_.scene_);
}
inline void GetSceneResponse::_internal_set_scene(::Scene value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.scene_ = value;
}

// -------------------------------------------------------------------

// Effect

// uint32 duration = 1;
inline void Effect::clear_duration() {
  _impl_.duration_ = 0u;
}
inline ::uint32_t Effect::duration() const {
  // @@protoc_insertion_point(field_get:Effect.duration)
  return _internal_duration();
}
inline void Effect::set_duration(::uint32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:Effect.duration)
}
inline ::uint32_t Effect::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void Effect::_internal_set_duration(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_ = value;
}

// repeated .TimeStamp timestamps = 2;
inline int Effect::_internal_timestamps_size() const {
  return _internal_timestamps().size();
}
inline int Effect::timestamps_size() const {
  return _internal_timestamps_size();
}
inline void Effect::clear_timestamps() {
  _internal_mutable_timestamps()->Clear();
}
inline ::TimeStamp* Effect::mutable_timestamps(int index) {
  // @@protoc_insertion_point(field_mutable:Effect.timestamps)
  return _internal_mutable_timestamps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TimeStamp >*
Effect::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:Effect.timestamps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_timestamps();
}
inline const ::TimeStamp& Effect::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:Effect.timestamps)
    return _internal_timestamps().Get(index);
}
inline ::TimeStamp* Effect::add_timestamps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TimeStamp* _add = _internal_mutable_timestamps()->Add();
  // @@protoc_insertion_point(field_add:Effect.timestamps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::TimeStamp >&
Effect::timestamps() const {
  // @@protoc_insertion_point(field_list:Effect.timestamps)
  return _internal_timestamps();
}
inline const ::google::protobuf::RepeatedPtrField<::TimeStamp>&
Effect::_internal_timestamps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamps_;
}
inline ::google::protobuf::RepeatedPtrField<::TimeStamp>*
Effect::_internal_mutable_timestamps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.timestamps_;
}

// -------------------------------------------------------------------

// UpgradeFirmwareRequest

// -------------------------------------------------------------------

// UpgradeFirmwareResponse

// bool is_latest_version = 1;
inline void UpgradeFirmwareResponse::clear_is_latest_version() {
  _impl_.is_latest_version_ = false;
}
inline bool UpgradeFirmwareResponse::is_latest_version() const {
  // @@protoc_insertion_point(field_get:UpgradeFirmwareResponse.is_latest_version)
  return _internal_is_latest_version();
}
inline void UpgradeFirmwareResponse::set_is_latest_version(bool value) {
  _internal_set_is_latest_version(value);
  // @@protoc_insertion_point(field_set:UpgradeFirmwareResponse.is_latest_version)
}
inline bool UpgradeFirmwareResponse::_internal_is_latest_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_latest_version_;
}
inline void UpgradeFirmwareResponse::_internal_set_is_latest_version(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_latest_version_ = value;
}

// string current_version = 2;
inline void UpgradeFirmwareResponse::clear_current_version() {
  _impl_.current_version_.ClearToEmpty();
}
inline const std::string& UpgradeFirmwareResponse::current_version() const {
  // @@protoc_insertion_point(field_get:UpgradeFirmwareResponse.current_version)
  return _internal_current_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpgradeFirmwareResponse::set_current_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UpgradeFirmwareResponse.current_version)
}
inline std::string* UpgradeFirmwareResponse::mutable_current_version() {
  std::string* _s = _internal_mutable_current_version();
  // @@protoc_insertion_point(field_mutable:UpgradeFirmwareResponse.current_version)
  return _s;
}
inline const std::string& UpgradeFirmwareResponse::_internal_current_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_version_.Get();
}
inline void UpgradeFirmwareResponse::_internal_set_current_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_version_.Set(value, GetArenaForAllocation());
}
inline std::string* UpgradeFirmwareResponse::_internal_mutable_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.current_version_.Mutable( GetArenaForAllocation());
}
inline std::string* UpgradeFirmwareResponse::release_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:UpgradeFirmwareResponse.current_version)
  return _impl_.current_version_.Release();
}
inline void UpgradeFirmwareResponse::set_allocated_current_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_version_.IsDefault()) {
          _impl_.current_version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UpgradeFirmwareResponse.current_version)
}

// -------------------------------------------------------------------

// TimeStamp

// uint32 seconds = 1;
inline void TimeStamp::clear_seconds() {
  _impl_.seconds_ = 0u;
}
inline ::uint32_t TimeStamp::seconds() const {
  // @@protoc_insertion_point(field_get:TimeStamp.seconds)
  return _internal_seconds();
}
inline void TimeStamp::set_seconds(::uint32_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:TimeStamp.seconds)
}
inline ::uint32_t TimeStamp::_internal_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seconds_;
}
inline void TimeStamp::_internal_set_seconds(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seconds_ = value;
}

// optional uint32 white = 3;
inline bool TimeStamp::has_white() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TimeStamp::clear_white() {
  _impl_.white_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TimeStamp::white() const {
  // @@protoc_insertion_point(field_get:TimeStamp.white)
  return _internal_white();
}
inline void TimeStamp::set_white(::uint32_t value) {
  _internal_set_white(value);
  // @@protoc_insertion_point(field_set:TimeStamp.white)
}
inline ::uint32_t TimeStamp::_internal_white() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.white_;
}
inline void TimeStamp::_internal_set_white(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.white_ = value;
}

// optional uint32 warm_white = 4;
inline bool TimeStamp::has_warm_white() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TimeStamp::clear_warm_white() {
  _impl_.warm_white_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TimeStamp::warm_white() const {
  // @@protoc_insertion_point(field_get:TimeStamp.warm_white)
  return _internal_warm_white();
}
inline void TimeStamp::set_warm_white(::uint32_t value) {
  _internal_set_warm_white(value);
  // @@protoc_insertion_point(field_set:TimeStamp.warm_white)
}
inline ::uint32_t TimeStamp::_internal_warm_white() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.warm_white_;
}
inline void TimeStamp::_internal_set_warm_white(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.warm_white_ = value;
}

// optional uint32 red = 5;
inline bool TimeStamp::has_red() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TimeStamp::clear_red() {
  _impl_.red_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t TimeStamp::red() const {
  // @@protoc_insertion_point(field_get:TimeStamp.red)
  return _internal_red();
}
inline void TimeStamp::set_red(::uint32_t value) {
  _internal_set_red(value);
  // @@protoc_insertion_point(field_set:TimeStamp.red)
}
inline ::uint32_t TimeStamp::_internal_red() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.red_;
}
inline void TimeStamp::_internal_set_red(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.red_ = value;
}

// optional uint32 green = 6;
inline bool TimeStamp::has_green() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TimeStamp::clear_green() {
  _impl_.green_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t TimeStamp::green() const {
  // @@protoc_insertion_point(field_get:TimeStamp.green)
  return _internal_green();
}
inline void TimeStamp::set_green(::uint32_t value) {
  _internal_set_green(value);
  // @@protoc_insertion_point(field_set:TimeStamp.green)
}
inline ::uint32_t TimeStamp::_internal_green() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.green_;
}
inline void TimeStamp::_internal_set_green(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.green_ = value;
}

// optional uint32 blue = 7;
inline bool TimeStamp::has_blue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TimeStamp::clear_blue() {
  _impl_.blue_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t TimeStamp::blue() const {
  // @@protoc_insertion_point(field_get:TimeStamp.blue)
  return _internal_blue();
}
inline void TimeStamp::set_blue(::uint32_t value) {
  _internal_set_blue(value);
  // @@protoc_insertion_point(field_set:TimeStamp.blue)
}
inline ::uint32_t TimeStamp::_internal_blue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blue_;
}
inline void TimeStamp::_internal_set_blue(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.blue_ = value;
}

// optional uint32 royal_blue = 8;
inline bool TimeStamp::has_royal_blue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TimeStamp::clear_royal_blue() {
  _impl_.royal_blue_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t TimeStamp::royal_blue() const {
  // @@protoc_insertion_point(field_get:TimeStamp.royal_blue)
  return _internal_royal_blue();
}
inline void TimeStamp::set_royal_blue(::uint32_t value) {
  _internal_set_royal_blue(value);
  // @@protoc_insertion_point(field_set:TimeStamp.royal_blue)
}
inline ::uint32_t TimeStamp::_internal_royal_blue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.royal_blue_;
}
inline void TimeStamp::_internal_set_royal_blue(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.royal_blue_ = value;
}

// optional uint32 ultra_violet = 9;
inline bool TimeStamp::has_ultra_violet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void TimeStamp::clear_ultra_violet() {
  _impl_.ultra_violet_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t TimeStamp::ultra_violet() const {
  // @@protoc_insertion_point(field_get:TimeStamp.ultra_violet)
  return _internal_ultra_violet();
}
inline void TimeStamp::set_ultra_violet(::uint32_t value) {
  _internal_set_ultra_violet(value);
  // @@protoc_insertion_point(field_set:TimeStamp.ultra_violet)
}
inline ::uint32_t TimeStamp::_internal_ultra_violet() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ultra_violet_;
}
inline void TimeStamp::_internal_set_ultra_violet(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ultra_violet_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::Scene> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Scene>() {
  return ::Scene_descriptor();
}
template <>
struct is_proto_enum<::CommandCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::CommandCode>() {
  return ::CommandCode_descriptor();
}
template <>
struct is_proto_enum<::Mode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Mode>() {
  return ::Mode_descriptor();
}
template <>
struct is_proto_enum<::LED> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::LED>() {
  return ::LED_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proto_2fmessage_2eproto_2epb_2eh
